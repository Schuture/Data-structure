'''
只出现过一次的数字系列，使用位运算的算法
诚然，可以使用O(n)时间复杂度的哈希表扫描方法来解这三道题，但是空间复杂度则无法保证
使用位运算的算法可以保证空间复杂度O(1)

先来复习一下位运算：
1、异或的性质
    两个数字异或的结果a^b是将 a 和 b 的二进制每一位进行运算，得出的数字。 
    运算的逻辑是：如果同一位的数字相同则为 0，不同则为 1

2、异或的规律
    任何数和本身异或则为0
    任何数和 0 异或是本身
'''

# 第一题，除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数
# 执行一次全员异或即可，因为出现过两次的数会抵消掉
def singleNumber1(nums):
    single_number = 0
    for num in nums:
        single_number ^= num
    return single_number

# 第二题，除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数
def singleNumber2(nums):
    res = 0
    for i in range(32):
        cnt = 0  # 记录当前 bit 有多少个1
        bit = 1 << i  # 记录当前要操作的 bit
        for num in nums:
            if num & bit != 0:
                cnt += 1
        if cnt % 3 != 0:
            # 不等于0说明唯一出现的数字在这个 bit 上是1
            res |= bit

    # 若没有溢出则直接返回，溢出则减去32位int的最大数字，变成负数（python中不会自动溢出）
    return res - 2 ** 32 if res > 2 ** 31 - 1 else res

# =============================================================================
# 第三题，除了两个数字出现一次，其他都出现了两次，让我们找到这个两个数。
# 我们进行一次全员异或操作，得到的结果就是那两个只出现一次的不同的数字的异或结果。
# 
# 我们刚才讲了异或的规律中有一个任何数和本身异或则为0，
# 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。
# 
# 分组需要满足两个条件：
# 1、两个独特的的数字分成不同组
# 2、相同的数字分成相同组
# 
# 这样每一组的数据进行异或即可得到那两个数字。
# 
# 问题的关键点是我们怎么进行分组呢？
# 
# 由于异或的性质是，同一位相同则为 0，不同则为 1。
# 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.
# 
# 我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。
# 这样肯定能保证条件2。相同的数字分成相同组, 不同的数字会被分成不同组么？很明显当然可以， 
# 因此我们选择是 1，也就是说两个独特的数字在那一位一定是不同的，因此两个独特元素一定会被分成不同组。
# =============================================================================
def singleNumbers3(nums):
    ret = 0  # 所有数字异或的结果
    a = 0
    b = 0
    for n in nums:
        ret ^= n
    # 找到第一位不是0的
    h = 1
    while(ret & h == 0):
        h <<= 1
    for n in nums:
        # 根据该位是否为0将其分为两组
        if (h & n == 0):
            a ^= n
        else:
            b ^= n

    return [a, b]

print(singleNumber1([1,1,2,2,3,3,4,5,5,6,6,7,7,8,8])) # 4只出现了一次
print(singleNumber2([1,1,1,2,3,3,3,4,4,4,5,5,5,6,6,6])) # 2只出现了一次
print(singleNumbers3([1,1,2,2,3,4,4,5,5,6,6,7,8,8,9,9])) # 3，7只出现了一次



























